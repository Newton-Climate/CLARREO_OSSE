#include <misc.h>
#include <params.h>
#define PCWDETRAIN

program main


!---------------------------Code history--------------------------------
!
!
!Dynamically allocated the arrays for modtran, so we stay -CAA-6/22/09
!   below the 2GB boundary.                                  
!
!
! 
!-----------------------------------------------------------------------

  
  use shr_kind_mod,  only: r8 => shr_kind_r8    
  use shr_const_mod, only: SHR_CONST_PI
  use shr_orb_mod
  use ppgrid
  use pmgrid
  use physconst,     only: gravit, latvap, cpair, tmelt, rga
  use physconst,     only: stebol, epsilo, pstd, rh2o, latice
  use physics_types, only: physics_state
  use radae,         only: initialize_radbuffer
  use constituents,  only: pcnst, ppcnst
  use ghg_surfvals,  only: scenario_ghg, ghg_surfvals_init, &
                           ghg_surfvals_ramp, ghg_surfvals_set
  use constituents,  only: cnst_get_ind
  use Chunks
  use RadInput
  use Output
  use pkg_cldoptics, only: cldefr, cldems, cldovrlap
  use chemistry,     only: trace_gas
  use prescribed_aerosols,  only: radforce, strat_volcanic, &
                                  tauback, sulscl, carscl, &
                                  ssltscl, dustscl, volcscl, &
                                  bgscl_rf, sulscl_rf, carscl_rf, &
                                  ssltscl_rf, dustscl_rf, volcscl_rf, &
                                  scenario_carbon_scale, &
                                  scenario_prescribed_sulfur, &
                                  prescribed_sulfur, &
                                  rampyear_prescribed_sulfur, &
                                  aerosol_initialize, get_int_scales, &
                                  get_aerosol, aerint

  use aer_optics,    only: aer_optics_initialize
  use volcanicmass,  only: read_volcanic_mass
  use commap,        only: latdeg, londeg
  use filenames,     only: absems_data, aeroptics, bndtvaer, bndtvcarbonscale, &
                           bndtvghg, bndtvo, bndtvscon, bndtvvolc, ncdata,  &
                           brdf_file,ocean_refl,snow_refl,phase_funcs
  use rgrid,         only: nlon
  use infnan,        only: bigint
  use time_manager,  only: mdbase, msbase, mbdate, mbsec, mdcur, &
                           mscur, mcdate, mcsec, calday
  use ramp_scon,     only: ramp_sconst, rampnl_scon
  use history, only: outfld !DRF
  use wv_saturation, only: aqsat !DRF
  use get_surface_properties, only: get_brdf,brdf_param,snow_reflectance, &
                                    ocean_reflectance,land_flag,ice_flag
  use get_phase_functions, only: get_pfs,phase_functions,phase_rhs, &
                                 phase_wvls,phase_angles
  use get_previous_results, only: load_previous_results, &
                                  starting_from_scratch,plat_start

#if ( defined MODTRAN_SPMD )
  use our_wrap_mpi
#endif


  implicit none

#include <comctl.h>
#include <comsol.h>
#include <comhyb.h>
#include <comlun.h>
!
! Flags for reconstruction/input
!
  character(len=16) :: build_aermmr     ! Build AERMMR internally
                                        !   ALL  = build all aerosols from
                                        !          climatology.  Volcanics
                                        !          read from separate climo.
                                        !   NONE = read in all aerosols
                                        !   IPCC = read in sulfate
                                        !          use climatology for other
                                        !          scale carbon aerosols
                                        !          read in volcanics
  logical :: build_trace                ! Build CFCs,CH4,& N2O internally
  logical :: build_emis                 ! Build EMIS internally
  logical :: build_re                   ! Build RE internally
  logical :: build_ozone                ! Build O3 internally 
  logical :: sol_ann_mean               ! Set eccf = 1.0 for insolation
  logical :: no_o2_abs                  ! Turn off absorption by O2 in SW

  character*16 scenario_scon
!                    ! values can be 'FIXED' or 'RAMPED'
!                    ! FIXED => scon is fixed and can either have preset or
!                    ! namelist value
!                    ! RAMPED => scon is ramped
!                    ! DEFAULT => FIXED
  integer rampYear_scon
!                    ! ramped scon fixed at this year if set to a value
!                    ! greater than zero.  Default value is 0.

!---------------------------Radiation Output----------------------------

#include <ptrrgrid.h>
  real(r8) :: qrs(plon,pver,plat)       ! Shortwave heating rate
  real(r8) :: qrl(plon,pver,plat)       ! Longwave  heating rate
  real(r8) :: flwds(plon,plat)          ! Surface longwave down flux
  real(r8) :: fsns(plon,plat)           ! Surface solar absorbed flux
  real(r8) :: fsnt(plon,plat)           ! Net column abs solar flux at model top
  real(r8) :: flns(plon,plat)           ! Srf longwave cooling (up-down) flux
  real(r8) :: flnt(plon,plat)           ! Net outgoing lw flux at model top
  real(r8) :: sols(plon,plat)           ! Direct beam solar rad. onto srf (sw)
  real(r8) :: soll(plon,plat)           ! Direct beam solar rad. onto srf (lw)
  real(r8) :: solsd(plon,plat)          ! Diffuse solar radiation onto srf (sw)
  real(r8) :: solld(plon,plat)          ! Diffuse solar radiation onto srf (lw)

  real(r8) :: FLNSC(plon,plat)          ! Net surface clear-sky longwave
  real(r8) :: FLNTC(plon,plat)          ! Net TOA clear-sky longwave
  real(r8) :: FSDS(plon,plat)           ! Downwelling surface shortwave
  real(r8) :: FSDSC(plon,plat)          ! Downwelling clear surface shortwave
  real(r8) :: FSNSC(plon,plat)          ! Net surface clear shortwave
  real(r8) :: FSNTC(plon,plat)          ! Net TOA cear shortwave
  real(r8) :: SOLIN(plon,plat)          ! TOA insolation
  real(r8) :: FLN200(plon,plat)         ! Net all-sky LW flux at 200 mb
  real(r8) :: FLN200C(plon,plat)        ! Net clear-sky LW flux at 200 mb
  real(r8) :: FSN200(plon,plat)         ! Net all-sky SW flux at 200 mb
  real(r8) :: FSN200C(plon,plat)        ! Net clear-sky SW flux at 200 mb

  real(r8) :: FLN(plon,pverp,plat)      ! Net longwave flux at each interface
  real(r8) :: FSN(plon,pverp,plat)      ! Net shortwave flux at each interface
  real(r8) :: aertau(plon,aertau_species,plat)  ! aerosol optical depths calculated by radcswmx.F90 (DRF)
  real(r8) :: o3vmr(pcols,pverr)        ! Ozone volume mixing ratio (DRF)
  real(r8) :: pbr(pcols,pverr)          ! Model mid-level pressures (dynes/cm2) (DRF)
  real(r8) :: pnm(pcols,pverrp)         ! Model interface pressures (dynes/cm2) (DRF)
  real(r8) :: eccf                      ! Earth/sun distance factor (DRF)
  real(r8) :: o3mmr(pcols,pverr)        ! Ozone mass mixing ratio (DRF)
  real(r8) :: esat(pcols,pverr)         ! saturation vapor pressure (DRF)
  real(r8) :: qsat(pcols,pverr)         ! saturation specific humidity (DRF)
  real(r8) :: rhq(pcols,pverr)          ! relative humidity from aqsat (DRF)
  real(r8) :: dummy(pcols)              !dummy variable (DRF)
  
  !Allocate memory for the arrays for modtran at runtime
  real*4, allocatable :: wavelength_lres(:)     !Wavelength values from Modtran (DRF)
  real*4, allocatable :: radiance_lres_clr(:,:,:)   !Radiance values from Modtran (DRF) clear-sky
  real*4, allocatable :: radiance_lres_all(:,:,:)   !Radiance values from Modtran (DRF) all-sky
  real*4, allocatable :: wavelength_hres(:)     !Wavelength values from Modtran (DRF)
  real*4, allocatable :: radiance_hres_clr(:,:,:)   !Radiance values from Modtran (DRF) clear-sky
  real*4, allocatable :: radiance_hres_all(:,:,:)   !Radiance values from Modtran (DRF) all-sky
  real*4, allocatable :: solar_flux(:,:,:)      !TOA downwelling solar flux values from Modtran (DRF)
  real*4, allocatable :: diffuse_flux_clr(:,:,:)    !Diffuse shortwave flux from Modtran (DRF) clear-sky
  real*4, allocatable :: diffuse_flux_all(:,:,:)    !Diffuse shortwave flux from Modtran (DRF) all-sky
  real*4, allocatable :: solar_zenith(:,:)      !Solar zenith angle from Modtran (DRF)
  real*4, allocatable :: aod(:,:)         !Solar zenith angle from Modtran (DRF)
  real*4, allocatable :: tau_sulf(:,:)         !Solar zenith angle from Modtran (DRF)
  real*4, allocatable :: tau_dust(:,:)         !Solar zenith angle from Modtran (DRF)
  real*4, allocatable :: tau_soot(:,:)         !Solar zenith angle from Modtran (DRF)
  real*4, allocatable :: tau_sslt(:,:)         !Solar zenith angle from Modtran (DRF)
  real*4, allocatable :: bb_updiffuse_clr(:,:,:)   !layer boundary upward diffuse broad-band flux (DRF)
  real*4, allocatable :: bb_updiffuse_all(:,:,:)   !layer boundary upward diffuse broad-band flux (DRF)
  real*4, allocatable :: bb_dndiffuse_clr(:,:,:)   !layer boundary downward diffuse broad-band flux (DRF)
  real*4, allocatable :: bb_dndiffuse_all(:,:,:)   !layer boundary downward diffuse broad-band flux (DRF)
  real*4, allocatable :: bb_dndirect_clr(:,:,:)   !layer boundary downward direct broad-band flux (DRF)
  real*4, allocatable :: bb_dndirect_all(:,:,:)   !layer boundary downward direct broad-band flux (DRF)
!  real*4, allocatable :: wavelength_lres_block(:)    !Wavelength values from Modtran (DRF)
!  real*4, allocatable :: wavelength_hres_block(:)    !Wavelength values from Modtran (DRF)

real*4, allocatable  ::  mpi_singles_block(:)
real*4, allocatable :: mpi_wvlnglres_block(:)    !Wavelength values from Modtran (DRF)
real*4, allocatable :: mpi_wvlnghres_block(:)    !Wavelength values from Modtran (DRF)
real*4, allocatable :: mpi_level_block(:)    !level values (fluxes) from Modtran (DRF)

!BEGIN ADD OF RADCSWMX
real(r8), allocatable :: mpi_singles_block2(:) !single values from radcswmx.F90
real(r8), allocatable :: mpi_level_block2(:)   !level values from radcswmx.F90
!END ADD OF RADCSWMX


!
!---------------------------Local workspace-----------------------------
!

  integer  :: iargc                     ! Routine to count arguments
  integer  :: jarg                      ! Counter for arguments

  type(physics_state) :: state(plat)    ! state information
  
  real(r8) :: aermmr(pcols,pver,plat)   ! level aerosol mass mixing ratio
  real(r8) :: rh(pcols,pver,plat)       ! level relative humidity (fraction)

  real(r8) :: pmid(plon,pver,plat)      ! midpoint pressure (Pa) 
  real(r8) :: pdel(plon,pver,plat)      ! layer thickness (Pa)
  real(r8) :: lnpmid(plon,pver,plat)    ! ln(pmid)
  real(r8) :: pint(plon,pver+1,plat)    ! interface pressure (Pa)
  real(r8) :: lnpint(plon,pver+1,plat)  ! ln(pint)

  real(r8) :: gicewp(plon,pver,plat)    ! grid-box average IWP
  real(r8) :: gliqwp(plon,pver,plat)    ! grid-box average LWP
  real(r8) :: cldice(plon,pver,plat)    ! grid-box average ice mixing ratio
  real(r8) :: cldliq(plon,pver,plat)    ! grid-box average liq. mixing ratio
  real(r8) :: ficemr(plon,pver,plat)    ! fraction of ice in condensate, by mr
  real(r8) :: cwp(plon,pver,plat)       ! total in-cloud condensate water path
  real(r8) :: lwp(plon,pver,plat)       ! liquid condensate in-cloud water path

  real(r8) :: clat(plon,plat)           ! current latitudes(radians)
  real(r8) :: clon(plon,plat)           ! current longitude (radians)

  real(r8) :: coszrs(plon,plat)         ! Cosine solar zenith angle
  integer ::  nslice                    ! number of time slices in file
  integer, pointer ::  nstep(:)         ! current time step
  integer, pointer ::  date(:)          ! current date
  integer, pointer ::  datesec(:)       ! current second in date
  real(r8) :: dtime                     ! length of time step (seconds)

  real(r8) :: qm1(plon,pver,ppcnst,plat)! Tracers
  real(r8) :: aerosol(plon,pver,naer_all,plat) ! aerosol mass mixing ratios
  real(r8) :: scales(naer_all)          ! scaling factors for aerosols


  real(r8) pmxrgn(plon,pverp,plat)      ! Maximum values of pressure for each
                                        !  maximally overlapped region.
                                        !  0->pmxrgn(i,1)=range of pressure for
                                        !  1st region,
                                        !  pmxrgn(i,1)->pmxrgn(i,2) for  
                                        !  2nd region, etc
  integer nmxrgn(plon,plat)             ! Number of maximally overlapped regions

  character(len=120) :: ipath1          ! Path to input data from 1st run.
  character(len=120) :: ipath2          ! Path to input data from 2nd run.
  character(len=120) :: opath           ! Path to output data.

  integer :: itime                      ! Time index
  integer :: j                          ! Latitude index
  integer :: ih2o                       ! Index for H2O
  integer :: in2o                       ! Index for N2O
  integer :: ich4                       ! Index for CH4
  integer :: if11                       ! Index for CFC11
  integer :: if12                       ! Index for CFC12
  integer :: iaer                       ! Counter for aerosol species
  integer :: kaer                       ! Index for aerosol species

  integer :: fld_option                 ! Option for field switching
                                        !   0 = no switch
                                        !   1 = swap temperatures (T and TS)
                                        !   2 = swap spec. humidity (Q)
                                        !   3 = swap clouds
                                        !   4 = swap albedos
                                        !   5 = perform swaps 1-4

  integer :: qr_option                  ! Option for outputting heating rates
                                        !   0 = no QRL/QRS on output
                                        !   1 = QRL/QRS on output


  integer :: usrsys                     ! Flag for timing

  logical :: log_print                  ! Flag for diagnostic output from orbital
  logical :: create_output_flag         ! DRF flag for whether of not output file should be created (for restart)





!MPI-------------------------------------------------------
 
  integer :: ierr,tag,i,proc_number
  integer :: my_rank
  integer :: tot_tasks
  logical :: our_master_proc
  integer :: my_latitude_start
  integer :: my_latitude_end
  integer :: my_longitude_start
  integer :: my_longitude_end

  real(r8) ::  total_time_start, total_time_end
  real(r8) ::  r0_message_start, r0_message_end
  real(r8) ::  r1_message_start, r1_message_end

 
 
 
  ! code to be timed



!  real(r4) :: low_wavelength_block,high_wavelength_block

  integer :: total_lat,total_long  !lat=128,lon=256
  integer :: lat_chunk,long_chunk

!-----------------------------------------------------------












  namelist /settings/ absems_data, aeroptics, bndtvaer, bndtvcarbonscale, &
                      bndtvghg, bndtvo, bndtvscon, bndtvvolc, ncdata, &
                      build_emis, build_re, scon, iyear_AD, scenario_scon, &
                      rampYear_scon, sol_ann_mean, no_o2_abs, &
                      build_trace, scenario_ghg, &
                      build_aermmr, &
                      radforce, tauback, sulscl, carscl, ssltscl, dustscl, &
                      volcscl, bgscl_rf, sulscl_rf, carscl_rf, ssltscl_rf, &
                      dustscl_rf, volcscl_rf, build_ozone, ozncyc, &
                      ipath1, ipath2, opath, fld_option, qr_option,brdf_file, &
                      ocean_refl,snow_refl,phase_funcs

!======================================================================

! Settings:
!   1. Climate sensitivity
!      build_aermmr =  'ALL'
!      build_trace =   .TRUE.
!      build_emis =    .TRUE.
!      build_re =      .TRUE.
!      build_ozone =   .TRUE.
!      scenario_scon = 'FIXED'
!      scenario_ghg  = 'FIXED'
!      ozncyc        = .TRUE.
!      strat_volcanic= .FALSE.
!   2. Climate sensitivity
!      build_aermmr =  'IPCC'
!      build_trace =   .FALSE.
!      build_emis =    .TRUE.
!      build_re =      .TRUE.
!      build_ozone =   .TRUE.
!      scenario_scon = 'RAMPED'
!      rampYear_scon = 0 (allow constant to vary)
!      scenario_ghg  = 'FIXED'*
!      ozncyc        = .FALSE.
!      strat_volcanic= .TRUE. itime
!
!* -- since GHG loss mechanism is on, we read CH4,N2O, & CFCs from history,
!     and we input CO2 from the 1D time series now included
!     in history files
!
! Notes: 
! 1. Split build_aermmr into flags for each species?  Current
!    behavior for IPCC is complicated -- some data are read, some are
!    reconstructed, some are scaled.
! 2. build_ozone flag is 
!    misnamed -- build_ozone just interpolates using the ozone boundary
!    data rather than reading it from the history file.
! 3. GHGs -- need consistent nomenclature between "trace" gases and "ghg"
!    control variables.
! 4. Flag for solar forcing for consistency?

!
!----------------------------------------------------------------------
! INITIALIZE MPI
!----------------------------------------------------------------------
!
  tag=0
  my_rank = 0
  our_master_proc = .true.
  tot_tasks = 0
  total_lat=2
  total_long=6
  !my_longitude_start=1
  !my_longitude_end=6 !6
  my_longitude_start = 58
  my_longitude_end = 63

  
if (my_rank == 0) then
total_time_start = our_mpi_wtime()
endif



#if ( defined MODTRAN_SPMD )


  call our_mpiinit()
  call our_mpicommrank( my_rank )
  call our_mpicommsize( tot_tasks )
  PRINT *, "task_no is ", my_rank, " of total ", tot_tasks, " tasks"



#endif

  if (my_rank == 0) then
open( unit=60, file="rank0timing.txt", &
      position="append", action="write" )
endif

if (my_rank == 1) then
open( unit=61, file="rank1timing.txt", &
      position="append", action="write" )
endif



  if (my_rank == 0) then
    our_master_proc = .true.
  else
    our_master_proc = .false.
  endif
  
 
 



  lat_chunk = INT( total_lat/tot_tasks )

  
  my_latitude_start= (my_rank*lat_chunk)+1

  if(my_rank==(tot_tasks-1))then
    my_latitude_end= total_lat
  else
    my_latitude_end= (my_rank+1)*lat_chunk
  endif






PRINT *, "total tasks=",tot_tasks," lat_chunk=",lat_chunk



!PRINT *, "my rank is ", my_rank, &
!         " start lat=", my_latitude_start, &
!         " end lat=",my_latitude_end,   & 
!         " start long=", my_longitude_start,  &
!         " end long=",my_longitude_end    















!  PRINT *, "********************INIT_MPI*******************************************************************"
!  PRINT *, "my rank is ", my_rank, " my master_proc value is", our_master_proc
!  PRINT *, "my rank is ", my_rank, " my start lat is=", my_latitude_start,  &
!           " my end lat is=",my_latitude_end 
!  PRINT *, "********************INIT_MPI*******************************************************************"





!
!----------------------------------------------------------------------
! ALLOCATE MEMORY FOR MODTRAN ARRAYS
!----------------------------------------------------------------------
!
 
  allocate (wavelength_lres(wvlng))             !Wavelength values from Modtran (DRF)
  allocate (radiance_lres_clr(plon,wvlng,plat))     !Radiance values from Modtran (DRF) clear-sky
  allocate (radiance_lres_all(plon,wvlng,plat))     !Radiance values from Modtran (DRF) all-sky
  allocate (wavelength_hres(wvlng_hres))        !Wavelength values from Modtran (DRF)
  allocate (radiance_hres_clr(plon,wvlng_hres,plat))!Radiance values from Modtran (DRF) clear-sky
  allocate (radiance_hres_all(plon,wvlng_hres,plat))!Radiance values from Modtran (DRF) all-sky
  allocate (solar_flux(plon,wvlng,plat))        !TOA downwelling solar flux values from Modtran (DRF)
  allocate (diffuse_flux_clr(plon,wvlng,plat))      !Diffuse shortwave flux from Modtran (DRF) clear-sky
  allocate (diffuse_flux_all(plon,wvlng,plat))      !Diffuse shortwave flux from Modtran (DRF) all-sky
  allocate (solar_zenith(plon,plat))            !Solar zenith angle from Modtran (DRF)
  allocate (aod(plon,plat))                     !Solar zenith angle from Modtran (DRF)
  allocate (tau_sulf(plon,plat))                     !Solar zenith angle from Modtran (DRF)
  allocate (tau_dust(plon,plat))                     !Solar zenith angle from Modtran (DRF)
  allocate (tau_soot(plon,plat))                     !Solar zenith angle from Modtran (DRF)
  allocate (tau_sslt(plon,plat))                     !Solar zenith angle from Modtran (DRF)
  allocate (bb_updiffuse_clr(plon,pver,plat))   !layer boundary upward diffuse broad-band flux (DRF)
  allocate (bb_updiffuse_all(plon,pver,plat))   !layer boundary upward diffuse broad-band flux (DRF)
  allocate (bb_dndiffuse_clr(plon,pver,plat))   !layer boundary downward diffuse broad-band flux (DRF)
  allocate (bb_dndiffuse_all(plon,pver,plat))   !layer boundary downward diffuse broad-band flux (DRF)
  allocate (bb_dndirect_clr(plon,pver,plat))   !layer boundary downward direct broad-band flux (DRF)
  allocate (bb_dndirect_all(plon,pver,plat))   !layer boundary downward direct broad-band flux (DRF)
!  allocate (wavelength_lres_block(wvlng))       !Wavelength values from Modtran (DRF)
!  allocate (wavelength_hres_block(wvlng_hres))  !Wavelength values from Modtran (DRF)
  allocate (mpi_singles_block(6))
  allocate (mpi_wvlnglres_block(5*wvlng))    !Wavelength values from Modtran (DRF)
  allocate (mpi_wvlnghres_block(2*wvlng_hres))    !Wavelength values from Modtran (DRF)
  allocate (mpi_level_block(6*pver))     !flux values from Modtran (DRF)

!BEGIN ADD OF RADCSWMX
  allocate (mpi_singles_block2(20))        !flux values, aod vals from radcswmx.F90
  allocate (mpi_level_block2(2*pverp+2*pver+aertau_species))     !heating rates, aod vals from radcswmx.F90
!END ADD OF RADCSWMX


!
!----------------------------------------------------------------------
! FIELD CONSTRUCTION FLAGS AND OTHER NAMELIST DEFAULTS
!----------------------------------------------------------------------
!
! DEFAULTS GIVEN BELOW ARE FOR IPCC
!

!>>> Cloud Properties <<<
  build_emis =   .TRUE.
  build_re =     .TRUE.

!>>> Solar <<<
  scon          = 1.367e6
  iyear_AD      = 1950

  scenario_scon = 'RAMPED'
  rampYear_scon = 0

  sol_ann_mean  = .FALSE.
  no_o2_abs     = .FALSE.

!>>> WMGHGs <<<
  build_trace =  .FALSE.
  scenario_ghg = 'FIXED'    

!>>> Aerosols <<<
  build_aermmr =  'IPCC'

  radforce   = .false. 

  tauback = 0._r8
  sulscl  = 1._r8
  carscl  = 1._r8
  ssltscl = 1._r8
  dustscl = 1._r8
  volcscl = 1._r8
  
  bgscl_rf   = 0._r8
  sulscl_rf  = 0._r8
  carscl_rf  = 0._r8
  ssltscl_rf = 0._r8
  dustscl_rf = 0._r8
  volcscl_rf = 0._r8
  
!>>> Ozone <<<
  build_ozone =  .TRUE.
  ozncyc = .FALSE.

!
! Filenames
!
  ipath1 = "in1.nc"
  ipath2 = "in2.nc"
  opath  = "output.nc"

!
! Options for input selection and heating rate output
!
  fld_option = 0
  qr_option  = 0

!
!----------------------------------------------------------------------
! INPUT/OUTPUT
!----------------------------------------------------------------------

  PRINT *, "********************INPUT/OUTPUT*************************************************************"
  PRINT *, "my rank is ", my_rank, " my master_proc value is", our_master_proc
  PRINT *, "my rank is ", my_rank, " my start lat is=", my_latitude_start,  &
           " my end lat is=",my_latitude_end 
  PRINT *, "********************INPUT/OUTPUT*************************************************************"






!DRF  if (iargc() /= 3) then 
!DRF     write(*,*) "Usage: input_1.nc input_2.nc output.nc < settings.inp"
!DRF     stop
!DRF  endif


 





  jarg = 1
!DRF  call getarg(jarg, ipath1)
 
  jarg = jarg + 1
!DRF  call getarg(jarg, ipath2)

  jarg = jarg + 1
!DRF  call getarg(jarg, opath)

  ipath1='/nobackupp3/dfeldman/esg/b30.042a.cam2.h0.2009-10.nc'
  ipath2='/nobackupp3/dfeldman/esg/b30.042a.cam2.h0.2009-10.nc'
  opath='b30.042a.cam2.h0.2009-10.out.nc'

  OPEN (UNIT=73, FILE='/home1/dfeldman/settings_forcing.inp')
 


  


PRINT *, "********************END OUTPUT*************************************************************"
  PRINT *, "my OUT1 rank is ", my_rank, " my master_proc value is", our_master_proc
  PRINT *, "my OUT1 rank is ", my_rank, " my start lat is=", my_latitude_start,  &
           " my end lat is=",my_latitude_end 
  PRINT *, "*******************END OUTPUT*************************************************************"


!if(my_rank==0) then
  read(73, nml=settings)
!endif



PRINT *, "********************END OUTPUT*************************************************************"
  PRINT *, "my OUT2 rank is ", my_rank, " my master_proc value is", our_master_proc
  PRINT *, "my OUT2 rank is ", my_rank, " my start lat is=", my_latitude_start,  &
           " my end lat is=",my_latitude_end 
  PRINT *, "*******************END OUTPUT*************************************************************"


  if (masterproc) then
     log_print = .TRUE.
  else
     log_print = .FALSE.
  end if




PRINT *, "********************END OUTPUT*************************************************************"
  PRINT *, "my OUT3 rank is ", my_rank, " my master_proc value is", our_master_proc
  PRINT *, "my OUT3 rank is ", my_rank, " my start lat is=", my_latitude_start,  &
           " my end lat is=",my_latitude_end 
  PRINT *, "*******************END OUTPUT*************************************************************"




!
! Input timing data (needed for solar ephemeris)
!

       


  call input_times(ipath1, nslice, nstep   ,dtime   ,mdbase  ,msbase  ,&
                   mbdate, mbsec, date, datesec)
  !write (*,*) "Here", ipath1, nslice, nstep   ,dtime   ,mdbase  ,msbase  ,&
  !                 mbdate, mbsec, date, datesec
!
! Input magic landm * cos(lat) flag if reconstructing rel/rei
!
  if (build_re) then
     call input_landmcos(ncdata)
  endif

!
! Check to see if output file already exists
!     call starting_from_scratch(opath,create_output_flag)

  create_output_flag = .true.
!
! Create output file if necessary
!


if (our_master_proc) then
  if (create_output_flag) then
     call create_output(ipath1, opath, nslice, date, datesec, qr_option)
  endif
endif
!
!----------------------------------------------------------------------
! MODEL GRID
!----------------------------------------------------------------------
! 
! Input vertical layer information and reconstruct hybrid coefficients
!    (needed for vertical grid analysis for aerosols and top level for
!     LW calculations)

  call input_vert_grid(ipath1)
  call hycoef()

!
! Set begchunk to 1 and endchunk to plat to allocate room for 
!     absorptivity/emissivity arrays
!
! In this code, the only place where begchunk and endchunk are used
!     is in the allocation of the absorptivity/emissivity arrays
!
  begchunk = 1
  endchunk = plat
!
! Set up rgrid module for volcanic mass interpolation
!
  nlon = plon

!
!----------------------------------------------------------------------
! SOLAR FORCING
!----------------------------------------------------------------------
!
! Solar and orbital constants
!
  call shr_orb_params (iyear_AD, eccen , obliq , mvelp, obliqr, &
                       lambm0, mvelpp, log_print)

!
! Determine ramping logic
!
   if (scenario_scon == 'FIXED') then
      doRamp_scon = .false.
   else if (scenario_scon == 'RAMPED') then
      doRamp_scon = .true.
   else
      call endrun ('READ_NAMELIST: SCENARIO_SCON must be set to either FIXED or RAMPED')
   endif
!       
! Initialize namelist related scon info
!
   if (doRamp_scon) then
      call rampnl_scon( rampYear_scon )
   endif

!
!----------------------------------------------------------------------
! GHG FORCING
!----------------------------------------------------------------------
!
! Initialize trace gas indices
!  NOTE: We use trace gas provision to load either reconstructed
!  profiles or input profiles of CH4,N2O, and CFC11/12 into slots
!  in the qm1 array.  This code will not work correctly if trace_gas = false
!
  trace_gas   = .TRUE.          

  call initindx()
  call cnst_get_ind('N2O'  , in2o)
  call cnst_get_ind('CH4'  , ich4)
  call cnst_get_ind('CFC11', if11)
  call cnst_get_ind('CFC12', if12)
  call cnst_get_ind('Q'    , ih2o)

  call ghg_surfvals_init()

!
!----------------------------------------------------------------------
! OZONE FORCING
!----------------------------------------------------------------------
!

!
! Set up to read ozone if build_ozone = .TRUE.
!  

  if (build_ozone) then
     call wrap_open(bndtvo, 0, ncid_oz)
!    oznini is called once we know the date, below.
  endif

!
!----------------------------------------------------------------------
! RADIATION INITIALIZATION
!----------------------------------------------------------------------


 PRINT *, "********************RAD*************************************************************"
  PRINT *, "my RAD rank is ", my_rank, " my master_proc value is", our_master_proc
  PRINT *, "my RAD rank is ", my_rank, " my start lat is=", my_latitude_start,  &
           " my end lat is=",my_latitude_end 
  PRINT *, "********************RAD*************************************************************"









!
! Initialize radiation
!
  call initialize_radbuffer()

  call radini  (gravit  ,cpair   ,epsilo  ,stebol  ,pstd*10.0)!

!
! Set up vapor tables needed for RH calculation for aerosol hygroscopic growth
!
  call esinti  (epsilo  ,latvap  ,latice  ,rh2o    ,cpair  , &
                tmelt   )   

!
! Various radiation settings
!
  dosw =       .TRUE.
  dolw =       .TRUE.
  indirect =   .FALSE.

!
! Establish frequency of abs/ems calculations. Logic from parse_namelist.F90
!

  iradae =     -12
  if (iradae < 0) iradae = nint((-iradae*3600.)/dtime)

!===================================================
! Radiation computations
!===================================================

  usrsys = 0
  call t_setoptionf(usrsys,1)
  call t_initializef()

  do itime = 1, nslice

     call input_data(ipath1, ipath2, fld_option, itime, &
                     build_aermmr, build_trace, build_emis, &
                     build_re, build_ozone)
     call transpose_input(build_aermmr, build_trace, build_emis, &
                          build_re, build_ozone)
     call dump_input_data()

     call calendr(nstep(itime),dtime   ,mdbase  ,msbase  ,mbdate  , &
                  mbsec   ,mdcur   ,mscur   ,mcdate  ,mcsec   , &
                  calday  )
     write(*,*) "Here", nstep(itime),dtime   ,mdbase  ,msbase  ,mbdate  , &
                  mbsec   ,mdcur   ,mscur   ,mcdate  ,mcsec   , &
                  calday  


     if (itime == 1) then

        plat_start = 1
!        if (.not.create_output_flag) then
!            call get_nc_varids(opath)  
!            call load_previous_results(opath,itime,FLN,FLNS,FLNSC,FLNT,FLNTC,   &
!                              FLN200,FLN200C,FSDS,FSDSC,FSN,FSNS,FSNSC,FSNT,FSNTC, &
!                              FSN200,FSN200C,QRL,QRS,SOLIN,SOLL,SOLLD,SOLS,SOLSD, &
!                              WAVELENGTH_LRES,RADIANCE_LRES_CLR,RADIANCE_LRES_ALL, &
!                              WAVELENGTH_HRES,RADIANCE_HRES_CLR,RADIANCE_HRES_ALL, &
!                              SOLAR_FLUX,DIFFUSE_FLUX_CLR,DIFFUSE_FLUX_ALL,SOLAR_ZENITH,AOD)            
!        endif

!
! Initialize aerosols.  This requires coordinates in input not
!   available until now.
!
        latdeg = c_lat
        do j = 1, plat
           londeg(1:plon,j) = c_lon(:)
        end do

        call aer_optics_initialize()
        call get_brdf(c_lat,c_lon,c_snowh,c_icefrac)
        call get_pfs()
        !write(*,*) "pfs = ",phase_functions(:,1,1,1)

        if (build_aermmr /= 'IPCC') then
           scenario_carbon_scale   = 'FIXED'
           strat_volcanic = .false.
        else
           scenario_carbon_scale   = 'RAMPED'
           strat_volcanic = .false.
        endif

        if (build_aermmr /= 'NONE') then
           scenario_prescribed_sulfur = 'FIXED' 
           prescribed_sulfur          = 'direct' 
           rampyear_prescribed_sulfur = bigint
           call aerosol_initialize()
        endif
!
! Initialize ozone.  This requires timeing information not available
!    until now
!
        if (build_ozone) then
           call oznini()
        endif
     endif
  

!
     if (dosw .or. dolw) then
!
! doabsems logic is identical to that in advnce.F90
!
        doabsems = nstep(itime).eq.0 .or. iradae.eq.1 .or. &
                   (mod(nstep(itime)-1,iradae).eq.0 .and. nstep(itime).ne.1)
        doabsems = .true.
        
        write(*,*) nstep(itime),dtime   ,mdbase  ,msbase  ,mbdate  , &
                     mbsec   ,mdcur   ,mscur   ,mcdate  ,mcsec   , &
                     calday
!
! Read next ozone, aerosol, and volcanic mass if needed
!        
        if (build_ozone) then 
           call oznint ()
        endif

        if (build_aermmr /= 'NONE') then
           call aerint ()
           if(strat_volcanic) then
              call read_volcanic_mass
           end if
        endif

        if (doRamp_scon) call ramp_sconst
!
! Set chunk index to latitude.  This is needed to pick appropriate
!     slice of absorptivity/emissivity 3D arrays
!
! See radclwmx for location where chunking is invoked to identify abs/ems sections
!
!$OMP PARALLEL DO PRIVATE (J)










        !Get value for restarting calculations, first read in previous values
!HARD-WIRE FOR DEBUG OF DGRD  (DRF)
         my_latitude_start = 44 
         my_latitude_end = 45
        do j= my_latitude_start, my_latitude_end  !plat_start,plat   !DRF
           write(*,*) "--> itime, ilat = ",itime,j

! Geographic coordinates and zenith angle calculations
!
           clat(:,j) = c_lat(j) / (180.0 / SHR_CONST_PI)
           clon(:,j) = c_lon(:) / (180.0 / SHR_CONST_PI)

           call zenith (calday, clat(:,j), clon(:,j), coszrs(:,j), pcols)
!
! Build pressure fields
!
           call plevs0(pcols, pcols, pver, c_ps(:,j), &
                       pint(:,:,j), pmid(:,:,j), pdel(:,:,j))
           lnpmid(:,:,j) = dlog(pmid(:,:,j))
           lnpint(:,:,j) = dlog(pint(:,:,j))
!
! Cloud particle size and fraction of ice
!
           
           if (build_re) then
              call cldefr(j,  pcols,    &
                   c_landfrac(:,j), c_t_cld(:,:,j), c_rel(:,:,j), &
                   c_rei(:,:,j), c_ps(:,j), pmid(:,:,j), c_landmcos(:,j), &
                   c_icefrac(:,j), c_snowh(:,j))
           endif
!
! Cloud emissivity.
!
           if (build_emis) then
!
! Reverse the code in param_cldoptics that computes icldiwp and icldlwp
!    to obtain the grid-box averaged condensate mixing ratios cldice & cldliq
!
              gicewp(:,:,j) = c_icldiwp(:,:,j) * max(0.01_r8, c_cloud(:,:,j))
              gliqwp(:,:,j) = (c_icldlwp(:,:,j) - c_icldiwp(:,:,j)) * &
                              max(0.01_r8, c_cloud(:,:,j)) 
              cldice(:,:,j) = gicewp(:,:,j) / (pdel(:,:,j) / gravit * 1000.0)
              cldliq(:,:,j) = gliqwp(:,:,j) / (pdel(:,:,j) / gravit * 1000.0)
!
! Now compute the ice mixing ratio and total condensate path using expressions
!     from param_cldoptics
!
              ficemr(:,:,j) = cldice(:,:,j) / &
                   max(1.e-10_r8, (cldice(:,:,j)+cldliq(:,:,j)))
              cwp(:,:,j) = c_icldlwp(:,:,j)

              call cldems(j, pcols, cwp(:,:,j), ficemr(:,:,j), &
                   c_rei(:,:,j), c_emis(:,:,j))
           endif
!
! Determine parameters for maximum/random overlap
!
           call cldovrlap(j, pcols, pint(:,:,j), c_cloud(:,:,j), &
                nmxrgn(:,j), pmxrgn(:,:,j))
!
! Reconstitute tracers
!
!
! Ramping ghg if appropriate.  Note -- just used for CO2 in IPCC runs.
!    In IPCC runs, build_trace = .false.
!
           if (ghg_surfvals_ramp()) call ghg_surfvals_set()

           if (build_trace) then
              call trcmix(j, pcols, pmid(:,:,j), &
                   qm1(:,:,in2o,j), qm1(:,:,ich4,j), &
                   qm1(:,:,if11,j), qm1(:,:,if12,j),clat(:,j))
           else
!
! Or transfer tracers
!
              qm1(:,:,in2o,j) = c_n2o(:,:,j)
              qm1(:,:,ich4,j) = c_ch4(:,:,j)
              qm1(:,:,if11,j) = c_cfc11(:,:,j)
              qm1(:,:,if12,j) = c_cfc12(:,:,j)
           endif
!
! Transfer humidity
!
           qm1(:,:,ih2o,j) = c_q(:,:,j)

!
! Aerosols: build aermmr fields if build_aermmr == 'ALL' or 'IPCC'
!
           if (build_aermmr /= 'NONE') then
              call get_int_scales(scales)

              call get_aerosol(j, pint(:,:,j), aerosol(:,:,:,j), scales)
           else
!
! Convert from mass to mixing ratio for everything except volcanics
!    Volcanic parameterizations expect mass per unit area in each layer
!
              do iaer = 1, naer_all
                 kaer = aerosol_index(iaer)
!
! The c_allaer is accumulated mass from the surface (k=pver) up to an arbitrary layer k'
!
                 aerosol(:,1:pver-1,kaer,j) = c_allaer(:,1:pver-1,j,kaer) - &
                                                c_allaer(:,2:pver,j,kaer)
                 aerosol(:,pver,kaer,j)     = c_allaer(:,pver,j,kaer)
!do j= my_latitude_start, my_latitude_end
! All aerosols besides volcanics should be expressed as mixing ratios
!
                 if (kaer /= idxVOLC) then
                    aerosol(:,:,kaer,j) = aerosol(:,:,kaer,j) / &
                                               (pdel(:,:,j) * rga)
                 endif
              end do
           endif

!           if (j .eq. 16) then
!              open(11,form='unformatted',file='aerosol_read.dat')
!              write(11) aerosol(:,:,:,j)
!              close(11)
!              stop
!           endif
           !stop
           if (build_aermmr == 'IPCC') then
!
! Determine index for sulfates
!
              kaer = minval(minloc(abs(aerosol_index - idxSUL)))
!
! The c_allaer is accumulated mass from the surface (k=pver) up to an arbitrary layer k'
!
              !DRF aerosol(:,1:pver-1,kaer,j) = c_allaer(:,1:pver-1,j,kaer) - &
              !DRF                                  c_allaer(:,2:pver,j,kaer)
              !DRF aerosol(:,pver,kaer,j)     = c_allaer(:,pver,j,kaer)


!
! All aerosols besides volcanics should be expressed as mixing ratios
!
              !DRF aerosol(:,:,kaer,j) = aerosol(:,:,kaer,j) / (pdel(:,:,j) * rga)
              aerosol(:,:,kaer,j) = c_allaer(:,:,j,kaer)
           endif
!              
! Complete radiation calculations
!
           state(j)%t           = c_t(:,:,j)
           state(j)%pmid        = pmid(:,:,j)
           state(j)%q(:,:,ih2o) = c_q(:,:,j)

!DRF !!!, LWP is positive           lwp(:,:,j) = (c_icldlwp(:,:,j) - c_icldiwp(:,:,j))
           lwp(:,:,j) = (c_icldlwp(:,:,j) )

!!! BEGIN DRF CHANGES
!
!   VARIABLE MAP BETWEEN radctl.F90 and Main.F90
!   radctl.F90 variable      Main.F90 variable
!   lchnk                    j
!   pcols                     pcols
!   pmid                     pmid(:,:,j)
!   pint                     pint(:,:,j)
!   o3vmr                    not defined
!   pbr                      not defined
!   pnm                      not defined
!   eccf                     not defined
!   o3mmr                    not defined
!   calday                   calday

!
! Interpolate ozone volume mixing ratio to model levels
!
   if (build_ozone) then
      call radozn(j   ,pcols    ,pmid(:,:,j)    ,o3vmr   )


      ! Set chunk dependent radiation input
      !
      call radinp(j   ,pcols,                                &
               pmid(:,:,j)    ,pint(:,:,j)    ,o3vmr   , pbr     ,&
#ifndef OFFLINE
               pnm     ,eccf    ,o3mmr   )
#else
               pnm     ,eccf    ,o3mmr   , calday)

      if (sol_ann_mean) then
         eccf = 1.0_r8
      endif
#endif
    else
      ! Set chunk dependent radiation input
      !
      call radinp(j   ,pcols,                                &
               pmid(:,:,j)    ,pint(:,:,j)    ,c_o3vmr(:,:,j)   , pbr     ,&
#ifndef OFFLINE
               pnm     ,eccf    ,o3mmr   )
#else
               pnm     ,eccf    ,o3mmr   , calday)

      if (sol_ann_mean) then
         eccf = 1.0_r8
      endif
#endif


   endif
   call outfld('O3VMR   ',o3vmr ,pcols, j)


!Get saturation water vapor pressure and relative humidity (DRF)
      call aqsat(state(j)%t, state(j)%pmid, esat, qsat, pcols, &
                 pcols, pver, 1, pver)

      ! calculate relative humidity
      rhq(1:pcols,1:pver) = state(j)%q(1:pcols,1:pver,1) / qsat(1:pcols,1:pver) * &
         ((1.0 - epsilo) * qsat(1:pcols,1:pver) + epsilo) / &
         ((1.0 - epsilo) * state(j)%q(1:pcols,1:pver,1) + epsilo)
      
      !DRF write(*,*) "co2vmr = ",co2vmr
           !write(*,*) "brdf = ",brdf_param(1,1,1,1,1)
           !write(*,*) "ocean_reflectance in main = ",ocean_reflectance(:,1)
      !Must return radiance values also
           call radctl (j, pcols, in2o, ich4, if11,if12, &
                c_lwup(:,j), c_emis(:,:,j), pmid(:,:,j), &
                pint(:,:,j), lnpmid(:,:,j), lnpint(:,:,j), c_t(:,:,j), &
                qm1(:,:,:,j), c_cloud(:,:,j), c_icldiwp(:,:,j), &
                lwp(:,:,j), coszrs(:,j), c_asdir(:,j), c_asdif(:,j), &
                c_aldir(:,j), c_aldif(:,j), pmxrgn(:,:,j), nmxrgn(:,j), &
                fsns(:,j), fsnt(:,j), flns(:,j), flnt(:,j), &
                qrs(:,:,j), qrl(:,:,j), flwds(:,j), c_rel(:,:,j), &
                c_rei(:,:,j), sols(:,j), soll(:,j), solsd(:,j), solld(:,j), &
                build_ozone, state(j), aerosol(:,:,:,j), calday, c_o3vmr(:,:,j), &
                flnsc(:,j), flntc(:,j), fsds(:,j), fsdsc(:,j), fsnsc(:,j), &
                fsntc(:,j), solin(:,j), fln200(:,j), fln200c(:,j), &
                fsn200(:,j), fsn200c(:,j), fln(:,:,j), fsn(:,:,j), aertau(:,:,j), &
                sol_ann_mean, no_o2_abs, pbr,pnm,eccf,o3mmr,esat, qsat,rhq, &
                c_lat(j),c_lon,co2vmr, wavelength_lres, radiance_lres_clr(:,:,j),radiance_lres_all(:,:,j), &
                wavelength_hres, radiance_hres_clr(:,:,j),radiance_hres_all(:,:,j), solar_flux(:,:,j), &
                land_flag(:,j), ice_flag(:,j),brdf_param(:,1,:,:,j), &
                ocean_reflectance,snow_reflectance, &
                phase_functions,phase_rhs,phase_wvls,phase_angles, &
                diffuse_flux_clr(:,:,j),diffuse_flux_all(:,:,j),solar_zenith(:,j),ipath1,mcdate, &
                aod(:,j), tau_sulf(:,j),tau_dust(:,j),tau_soot(:,j),tau_sslt(:,j), &
                bb_updiffuse_clr(:,:,j),bb_updiffuse_all(:,:,j), &
                bb_dndiffuse_clr(:,:,j),bb_dndiffuse_all(:,:,j), &
                bb_dndirect_clr(:,:,j), bb_dndirect_all(:,:,j), &             
                j,my_longitude_start,my_longitude_end,my_rank)

           qrl(:,:,j) = qrl(:,:,j) / cpair
           qrs(:,:,j) = qrs(:,:,j) / cpair

           fln(:,:,j) = fln(:,:,j) * 1.e-3
           fsn(:,:,j) = fsn(:,:,j) * 1.e-3
  
!          call write_output(opath, itime, FLN, FLNS, FLNSC, FLNT, FLNTC, &
!                          FLN200, FLN200C, &
!                          FSDS, FSDSC, FSN, FSNS, FSNSC, FSNT, FSNTC, &
!                          FSN200, FSN200C, &
!                          QRL, QRS, SOLIN, SOLL, SOLLD, SOLS, SOLSD, &
!                          WAVELENGTH_LRES,RADIANCE_LRES_CLR,RADIANCE_LRES_ALL,WAVELENGTH_HRES, &
!                          RADIANCE_HRES_CLR,RADIANCE_HRES_ALL,SOLAR_FLUX,DIFFUSE_FLUX_CLR,DIFFUSE_FLUX_ALL, & 
!                           SOLAR_ZENITH,AOD,qr_option) !DRF
!           stop "finished writing to main output file"
        end do ! end of loop over latitudes
     end if










if (my_rank == 0) then
r0_message_start = our_mpi_wtime()
endif





  !loop over all the processors besides processor 0
  do proc_number=1,(tot_tasks-1)

    if(my_rank==proc_number .or. my_rank==0)then

if (my_rank == 1) then
r1_message_start = our_mpi_wtime()
endif



      if(my_rank==0)then
      my_latitude_start= (proc_number*lat_chunk)+1

      if(proc_number==(tot_tasks-1))then
        my_latitude_end= total_lat
      else
        my_latitude_end= (proc_number+1)*lat_chunk
      endif
      endif


      do j=my_latitude_start,my_latitude_end
        do i=my_longitude_start,my_longitude_end

          if(my_rank==proc_number)then

            !PACK AND SEND

            mpi_singles_block(1)=solar_zenith(i,j)
            mpi_singles_block(2)=aod(i,j)
            mpi_singles_block(3)=tau_sulf(i,j)
            mpi_singles_block(4)=tau_dust(i,j)
            mpi_singles_block(5)=tau_soot(i,j)
            mpi_singles_block(6)=tau_sslt(i,j)
            tag=1

            call our_mpisendreal (mpi_singles_block, 6, 0, tag)

            mpi_wvlnghres_block(1:wvlng_hres)=radiance_hres_clr(i,:,j)
            mpi_wvlnghres_block(wvlng_hres+1:2*wvlng_hres)=radiance_hres_all(i,:,j)
            tag=2

            call our_mpisendreal (mpi_wvlnghres_block, 2*wvlng_hres, 0, tag)

            mpi_wvlnglres_block(1:wvlng)=radiance_lres_clr(i,:,j)
            mpi_wvlnglres_block(wvlng+1:2*wvlng)=radiance_lres_all(i,:,j)
            mpi_wvlnglres_block((2*wvlng)+1:3*wvlng)=diffuse_flux_clr(i,:,j)
            mpi_wvlnglres_block((3*wvlng)+1:4*wvlng)=diffuse_flux_all(i,:,j)
            mpi_wvlnglres_block((4*wvlng)+1:5*wvlng)=solar_flux(i,:,j)
            tag=3

            call our_mpisendreal (mpi_wvlnglres_block, 5*wvlng, 0, tag)

            mpi_level_block(1:pver) = bb_updiffuse_clr(i,:,j)
            mpi_level_block(1+pver:2*pver) = bb_updiffuse_all(i,:,j)
            mpi_level_block(1+2*pver:3*pver) = bb_dndiffuse_clr(i,:,j)
            mpi_level_block(1+3*pver:4*pver) = bb_dndiffuse_all(i,:,j)
            mpi_level_block(1+4*pver:5*pver) = bb_dndirect_clr(i,:,j)
            mpi_level_block(1+5*pver:6*pver) = bb_dndirect_all(i,:,j)
            tag=4

            call our_mpisendreal (mpi_level_block, 6*pver, 0, tag)

            !BEGIN ADD OF RADCSWMX
            mpi_singles_block2(1)=flns(i,j)
            mpi_singles_block2(2)=flnsc(i,j)
            mpi_singles_block2(3)=flnt(i,j)
            mpi_singles_block2(4)=flntc(i,j)
            mpi_singles_block2(5)=fln200(i,j)
            mpi_singles_block2(6)=fln200c(i,j)
            mpi_singles_block2(7)=fsds(i,j)
            mpi_singles_block2(8)=fsdsc(i,j)
            mpi_singles_block2(9)=fsns(i,j)
            mpi_singles_block2(10)=fsnt(i,j)
            mpi_singles_block2(11)=fsntc(i,j)
            mpi_singles_block2(12)=fsn200(i,j)
            mpi_singles_block2(13)=fsn200c(i,j)
            mpi_singles_block2(14)=solin(i,j)
            mpi_singles_block2(15)=soll(i,j)
            mpi_singles_block2(16)=solld(i,j)
            mpi_singles_block2(17)=sols(i,j)
            mpi_singles_block2(18)=solsd(i,j)
            tag=5
            call our_mpisenddouble(mpi_singles_block2, 18, 0, tag)

            mpi_level_block2(1:pverp)=fsn(i,:,j)
            mpi_level_block2(1+pverp:2*pverp)=fln(i,:,j)
            mpi_level_block2(1+2*pverp:2*pverp+pver)=qrl(i,:,j)
            mpi_level_block2(1+2*pverp+pver:2*pverp+2*pver)=qrs(i,:,j)
            mpi_level_block2(1+2*pverp+2*pver:aertau_species+2*pverp+2*pver)=aertau(i,:,j)
            tag=6
            call our_mpisenddouble (mpi_level_block2, 2*pver+2*pverp+aertau_species, 0, tag)
            !END ADD OF RADCSWMX

          endif !rank proc_number

          if(my_rank==0)then


            !RECEIVE AND UNPACK

            tag=1  
            call our_mpirecvreal (mpi_singles_block, 6, proc_number, tag)

            solar_zenith(i,j)=mpi_singles_block(1)
            aod(i,j)=mpi_singles_block(2)
            tau_sulf(i,j)=mpi_singles_block(3)
            tau_dust(i,j)=mpi_singles_block(4)
            tau_soot(i,j)=mpi_singles_block(5)
            tau_sslt(i,j)=mpi_singles_block(6)
            
            tag=2
            call our_mpirecvreal (mpi_wvlnghres_block, 2*wvlng_hres, proc_number, tag)

            radiance_hres_clr(i,:,j)=mpi_wvlnghres_block(1:wvlng_hres)
            radiance_hres_all(i,:,j)=mpi_wvlnghres_block(wvlng_hres+1:2*wvlng_hres)

            tag=3
            call our_mpirecvreal (mpi_wvlnglres_block, 5*wvlng, proc_number, tag)

            radiance_lres_clr(i,:,j)=mpi_wvlnglres_block(1:wvlng)
            radiance_lres_all(i,:,j)=mpi_wvlnglres_block(wvlng+1:2*wvlng)
            diffuse_flux_clr(i,:,j)=mpi_wvlnglres_block((2*wvlng)+1:3*wvlng)
            diffuse_flux_all(i,:,j)=mpi_wvlnglres_block((3*wvlng)+1:4*wvlng)
            solar_flux(i,:,j)=mpi_wvlnglres_block((4*wvlng)+1:5*wvlng)

            tag=4
            call our_mpirecvreal (mpi_level_block, 6*pver, proc_number, tag)
            bb_updiffuse_clr(i,:,j) = mpi_level_block(1:pver)
            bb_updiffuse_all(i,:,j) = mpi_level_block(1+pver:2*pver)
            bb_dndiffuse_clr(i,:,j) = mpi_level_block(1+2*pver:3*pver)
            bb_dndiffuse_all(i,:,j) = mpi_level_block(1+3*pver:4*pver)
            bb_dndirect_clr(i,:,j) = mpi_level_block(1+4*pver:5*pver)
            bb_dndirect_all(i,:,j) = mpi_level_block(1+5*pver:6*pver)

            !BEGIN ADD OF RADCSWMX
            tag=5  
            call our_mpirecvdouble (mpi_singles_block2, 18, proc_number, tag)

            flns(i,j) = mpi_singles_block2(1)
            flnsc(i,j) = mpi_singles_block2(2)
            flnt(i,j) = mpi_singles_block2(3)
            flntc(i,j) = mpi_singles_block2(4)
            fln200(i,j) = mpi_singles_block2(5)
            fln200c(i,j) = mpi_singles_block2(6)
            fsds(i,j) = mpi_singles_block2(7)
            fsdsc(i,j) = mpi_singles_block2(8)
            fsns(i,j) = mpi_singles_block2(9)
            fsnt(i,j) = mpi_singles_block2(10)
            fsntc(i,j) = mpi_singles_block2(11)
            fsn200(i,j) = mpi_singles_block2(12)
            fsn200c(i,j) = mpi_singles_block2(13)
            solin(i,j) = mpi_singles_block2(14)
            soll(i,j) = mpi_singles_block2(15)
            solld(i,j) = mpi_singles_block2(16)
            sols(i,j) = mpi_singles_block2(17)
            solsd(i,j) = mpi_singles_block2(18)

            tag=6  
            call our_mpirecvdouble (mpi_level_block2, 2*pver+2*pverp+aertau_species, proc_number, tag)
            fsn(i,:,j) = mpi_level_block2(1:pverp)
            fln(i,:,j) = mpi_level_block2(1+pverp:2*pverp)
            qrl(i,:,j) = mpi_level_block2(1+2*pverp:2*pverp+pver)
            qrs(i,:,j) = mpi_level_block2(1+2*pverp+pver:2*pverp+2*pver)
            aertau(i,:,j) = mpi_level_block2(1+2*pverp+2*pver:aertau_species+2*pverp+2*pver)
            !END ADD OF RADCSWMX
          
          endif !rank 0
        enddo !i
      enddo !j

if (my_rank == 1) then
r1_message_end = our_mpi_wtime()
endif


    endif !both ranks
!    call our_mpibarrier ()
  enddo !end of loop of processor number 


if (my_rank == 0) then
r0_message_end = our_mpi_wtime()
endif



   
     !Note: this here for now since at the end of the do loop itime will be increased by 1 thus printing out
     !another slice of time data which is irrelevant to us

     if (our_master_proc) then

     call write_output(opath, itime, FLN, FLNS, FLNSC, FLNT, FLNTC, &
                       FLN200, FLN200C, &
                       FSDS, FSDSC, FSN, FSNS, FSNSC, FSNT, FSNTC, &
                       FSN200, FSN200C, &
                       QRL, QRS, SOLIN, SOLL, SOLLD, SOLS, SOLSD, AERTAU, &
                       WAVELENGTH_LRES,RADIANCE_LRES_CLR,RADIANCE_LRES_ALL,WAVELENGTH_HRES, &
                       RADIANCE_HRES_CLR,RADIANCE_HRES_ALL,SOLAR_FLUX,DIFFUSE_FLUX_CLR,DIFFUSE_FLUX_ALL, & 
                       SOLAR_ZENITH,AOD,TAU_SULF,TAU_DUST,TAU_SOOT,TAU_SSLT, &
                       BB_UPDIFFUSE_CLR,BB_UPDIFFUSE_ALL, &
                       BB_DNDIFFUSE_CLR,BB_DNDIFFUSE_ALL, &
                       BB_DNDIRECT_CLR,BB_DNDIRECT_ALL,qr_option ) !DRF
     write(*,*) "finished with write_output"
 
     end if !our_master_proc
  
  end do ! end of loop over time


 

  call t_prf(0)




if (my_rank == 0) then
total_time_end = our_mpi_wtime()
endif


if (my_rank == 0) then
 write(60,*)"Total time of the program is ",total_time_end-total_time_start
 write(60,*)"Message time is ",r0_message_end-r0_message_start
endif


if (my_rank == 1) then
 write(61,*)"Message time is ",r1_message_end-r1_message_start
endif








if (my_rank == 0) then
CLOSE (UNIT=60) 
endif

if (my_rank == 1) then
CLOSE (UNIT=61) 
endif





#if ( defined MODTRAN_SPMD )
  call our_mpifinalize() 
#endif


  stop "End of program"
end program main
