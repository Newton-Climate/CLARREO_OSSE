      SUBROUTINE FDBETA(H1,H2,BETA,ANGLE,PHI,LENN,HMIN,IERROR)

!     PARAMETERS:
      INCLUDE 'ERROR.h'

!     GIVEN H1,H2,AND BETA (THE EARTH CENTERED ANGLE), THIS SUBROUTINE
!     CALCULATES THE ZENITH ANGLE AT H1 (ANGLE) AND AT H2 (PHI).
!     BASED ON A NEWTON-RAPHSON METHOD.

!     DECLARE ROUTINE ARGUMENTS:
      DOUBLE PRECISION H1,H2,BETA,ANGLE,PHI,HMIN
      INTEGER LENN,IERROR

!     LIST COMMONS:
      INCLUDE 'IFIL.h'
      REAL RE,ZMAX
      INTEGER IPATH
      COMMON/PARMTR/RE,ZMAX,IPATH
      REAL GNDALT
      COMMON/GRAUND/GNDALT

!     DECLARE BLOCK DATA ROUTINES EXTERNAL:
      EXTERNAL DEVCBD

!     DECLARE LOCAL VARIABLES:
      INTEGER IAMTB,ITER
      DOUBLE PRECISION HA,HB,BETA1,RANGE,BENDNG,ANGLE1,RATIOA,RATIOB,   &
     &  STORE,DENOM,DERIV,APREV,AWGHTD,DBPREV,DBETA,DPRE

!     LIST DATA:
      DOUBLE PRECISION TOLRNC,DPDEG
      INTEGER ITERMX
      LOGICAL LWARN
      DATA TOLRNC/2.D-4/,DPDEG/57.2957795131D0/,ITERMX/35/,LWARN/.TRUE./
      DPRE=DBLE(RE)
      IF(BETA.EQ.0.)THEN
         LENN=0
         ANGLE=DBLE(0.)
         HMIN=H1
         IF(H1.GT.H2)THEN
            ANGLE=DBLE(180.)
            HMIN=H2
         ENDIF
         PHI=DBLE(180.)-ANGLE
      ENDIF
      IF(H1.GT.H2)THEN
         HA=H2
         HB=H1
      ELSE
         HA=H1
         HB=H2
      ENDIF

!***  SET PARAMETER TO SUPPRESS CALCULATION OF AMOUNTS IN ROUTINE LAYER
      IAMTB = 2

!***  GUESS AT ANGLE,INTEGRATETO FIND BETA, TEST FOR CONVERGENCE, AND
!***  ITERATE FIRST GUESS AT ANGLE: USE GEOMETRIC SOLN (NO REFRACTION)
      IF(.NOT.LJMASS)WRITE(IPR,'(///30H CASE 2D: GIVEN H1, H2,  BETA:,//&
     &     42H ITERATE AROUND ANGLE UNTIL BETA CONVERGES,//             &
     &     14H ITER    ANGLE,T21,4HBETA,T30,5HDBETA,T40,5HRANGE,T51,    &
     &     4HHMIN,T61,3HPHI,T70,7HBENDING,/T10,5H(DEG),T21,5H(DEG),T30, &
     &     5H(DEG),T41,4H(KM),T51,4H(KM),T60,5H(DEG),T71,5H(DEG),/)')

!     CALCULATE ANGLE1, A GUESS VALUE FOR ANGLE
      RATIOA=(HB-HA)/(DPRE+HA)
      RATIOB=(HB-HA)/(DPRE+HB)
      STORE=2*SIN(DBLE(.5)*BETA/DPDEG)**2
      DENOM=RATIOB-STORE
      ANGLE1=DBLE(90.)
      IF(DENOM.NE.0.)ANGLE1=DPDEG*ATAN(SIN(BETA/DPDEG)/DENOM)
      IF(ANGLE1.LT.0.)ANGLE1=ANGLE1+DBLE(180.)

!     CALCULATE THE DERIVATIVE D(ANGLE)/D(BETA)
      DERIV=(RATIOA+STORE)/(RATIOA*RATIOB+2*STORE)

!     DERIV TENDS TO OVERSHOOT VALUE.  FUDGE (=.6) SPEEDS UP CONVERGENCE
      DERIV=DBLE(.6)*DERIV

!     BEGIN ITERATIVE PROCEDURE
      ITER=0
 10   ITER=ITER+1
      IF(.NOT.LJMASS .AND. ITER.GT.ITERMX)THEN
         WRITE(IPR,'(40H0FDBETA, CASE 2D (H1,H2,BETA): SOLUTION ,       &
     &        16HDID NOT CONVERGE,//10X,4HH1 =,F13.6,4X,4HH2 =,F13.6,   &
     &        4X,6HBETA =,F13.6,4X,12HITERATIONS =,I5,//10X,4HLAST,     &
     &        10H ITERATION,//10X,7HANGLE =,F16.9,4X,6HBETA =,F16.9)')  &
     &        H1,H2,BETA,ITER,ANGLE1,BETA1
         IERROR=1
         RETURN
      ENDIF

!     DETERMINE BETA1, THE BETA CORRESPONDING TO ANGLE1
      CALL DPFNMN(HA,ANGLE1,HB,LENN,ITER,HMIN,PHI,IERROR,LWARN)
      CALL DPRFPA(HA,HB,ANGLE1,PHI,LENN,HMIN,                           &
     &     IAMTB,BETA1,RANGE,BENDNG)
      IF(.NOT.LJMASS)WRITE(IPR,'(I5,3F10.4,2F10.3,2F10.4)')             &
     &     ITER,ANGLE1,BETA1,BETA-BETA1,RANGE,HMIN,PHI,BENDNG
      DBETA = BETA1-BETA
      AWGHTD=(ANGLE1*ABS(DBETA)+APREV*ABS(DBPREV))                      &
     &     /(ABS(DBETA)+ABS(DBPREV))

!     CHECK FOR CONVERGENCE
      IF(ABS(BETA-BETA1).LT.TOLRNC)THEN
         IF(.NOT.LJMASS .AND. HMIN.LT.GNDALT)THEN
            WRITE(IPR,'(3A,//9X,A)')'0FDBETA,',                         &
     &           ' CASE 2D(H1,H2,BETA): REFRACTED TANGENT HEIGHT',      &
     &           ' IS LESS THAN ZERO-PATH INTERSECTS THE EARTH',        &
     &           ' BETA IS TOO LARGE FOR THIS H1 AND H2'
            IERROR=1
         ELSEIF(H1.LE.H2)THEN
            BETA=BETA1
            ANGLE=ANGLE1
         ELSE
            BETA=BETA1
            ANGLE=PHI
            PHI=ANGLE1
         ENDIF
         RETURN
      ENDIF

      APREV =  ANGLE1
      IF (DBPREV*DBETA .LT. 0.0D00 .AND. ITER .GT. 5) THEN
         ANGLE1=AWGHTD
         DBPREV = BETA1 - BETA
      ELSE
         DBPREV = BETA1 - BETA
         ANGLE1=ANGLE1-DERIV*DBPREV
      ENDIF
      GOTO10

      END
